BSVM 2-1 Bytecode.

Model:
*  Args/Locals
*  Stack
*  Lexical
*  ...

Like JVM, Args will be locals 1-N, with local variables following args.

Alternately, could have locals first, followed by args. Reason: on average locals are used more than args, so this could lead to better code density, and deals better with variable argument lists.

Stack
All instructions at a given location will be required to have the same stack layout (depth and types) at all possible control paths. Values may be left on the stack during jumps, provided:
Both the start and destination have the same layout;
The layout for a label matches what it would be if control arrived via the preceding instruction.

Unconditional jumps will behave as-if all items have been popped from the stack.

 LDI src			//load integer (local->stack)
 STI dst			//store integer (stack->local)
 MVI dst, src	//move integer (local->local)
 ADDI			//A B => A+B
 ADDIL src		//A => A+src
 ADDIC const		//A => A+const


== Types ==

Core Types:
  I, Int (Int32, UInt32)
  L, Long
  F, Float
  D, Double
  A, Address

Sub-Types:
*  Int
**    byte/sbyte/ubyte
**    short/ushort
**    int/uint
**    char (16 bit, in storage)
**    char8 (8 bit)
*  Long
**    long/ulong (64 bit)
**    nlong/unlong (32 or 64 bit, non-core storage)
*  Float
**    float
**    hfloat (16-bit in storage)
*  Double
**    double
*  Address
**    object
**    array
**    pointer
**    variant
**    string
**    reference
**    ...

Implementation may treat arrays and pointers as siblings, both existing nominally as an offset relative to a base object. This base object will nominally be an array.

A raw pointer may then exist as a type of special Null-Array, which may extend over the entire address space.

Normally, the address will need to track what type it is. Addresses in this VM will generally not be raw pointers.

Logical comparison of an address values will depend on the type of objects involved. Strict comparisons will compare the bit patterns.

Logical relative comparisions of array values will compare the relative base offset within a single array. Comparisons between different arrays are undefined. The behavior of strict relative comparisons is undefined for arrays.


Operations on array and pointer types will be interchangable.

Variable References will exist as a disjoint type. In certain cases, a reference may be converted to a pointer, but pointer or array operations may not be used on references, nor reference operations on pointers or arrays.


Strings will be treated as immutable character arrays. Normal strings will be either narrow (8859-1) or wide (UCS-2 / UTF-16). As a variable, char will be represented as a signed 32-bit integer, however its storage in strings or arrays will be narrower. In arrays, char will be represented as an unsigned short. Strings may also exist as UTF-8.

Both objects and arrays may have reference counts. If the reference count for an object becomes 0, it is freed implicitly. Objects and arrays may also be copied to implement pass-by-value semantics, however, this will be managed primarily by the language and not by the VM.

The handling of reference counting will be explicit in the bytecode.

Copying between arrays or objects will require both to be the same type and size.


Native Long will be a non-core type which will primarily effect its storage size. It will generally be treated as a 64-bit long type in the bytecode. The size of an native long will match the size of a native machine address.

In cases where an NLong is used as a long, and is 32-bit in storage, it will be implicitly sign or zero extended to long. A native long is also to be able to be coerced to an int ('native long int').

Narrower types will implicitly widen to their parent core type, with the narrower type primarily effecting storage. As a result, intermediate arithmetic results may reflect the wider type.


=== X128 ===

X128 will be an extended-core type which exists as a subset of Address.

IOW:
* Address
** X128
*** int128
*** uint128
*** float128
*** vec2i/vec3i/vec4i
*** vec2l
*** vec2f/vec3f/vec4f
*** vec2d


An X128 value represents a 128 bit quantity, which may have one of several possible interpretations:
* 4 Integers
* 2 Longs
* 4 Floats
* 2 Doubles
* A 128 bit Integer (Int128/UInt128)
* A 128 bit Float (Float128)

Components will be labeled as:
* A, B, C, D
** The 4 32-bit elements
* AB, CD
** The 2 64-bit elements
* ABCD
** As a 128 bit element
* A will be the low-order bits, and D the high order bits.
** AB will thus be the low half of an Int128, and CD the upper half.

For vec3f and vec4f:
* X, Y, Z, W
** Where X=A and W=D

If the vector operation type is narrower than the full width of the vector, then the contents of the remaining vector elements is undefined.

Note that these vectors do not necessarily correspond with SIMD features provided by the underlying CPU architecture.


=== Signature Strings ===

Signature Characters:
*  a, sbyte (signed byte)
*  b, bool (byte)
*  c, char8
*  d, double
*  e, (long double)
*  f, float
*  g, float128
*  h, ubyte (unsigned byte)
*  i, int
*  j, uint
*  k, float16
*  l, native long
*  m, native ulong
*  n, int128
*  o, uint128
*  p, 
*  q, 
*  r, variant
*  s, short
*  t, ushort
*  u,
*  v, void
*  w, char (16-bit)
*  x, long
*  y, ulong
*  z, vararg (array of remaining arguments)
*  Cs, string
*  Pc, cstring

*  R*, Reference
*  P*, Pointer
*  Q*, Array (array reference)
*  X(id), struct (inline value object)
*  L(id), class or interface (object reference)
*  U(id), extended non-core types.


Function/Method signatures:
*  (args*)ret*
*  int foo(float x, double y);
** Would have the signature: "(fd)i"

For X and L, the id may be either a number or a Qname. Ex: "L1234" means the class at entry 1234, whereas "Lfoo/bar/baz;" gives a QName.


== Constant Pool ==

This will be done indirectly for bytecode.
/ Namely, the function or method will refer to a block-local table, which will hold indices into an image-level constant pool.

A per function global table will exist. This table may potentially contain constants, but will generally contain indices into GIX.


== Instruction Set ==

* 00-DF: Single Byte
* E0-EF: Two Byte (0000-0FFF)
* F0-F7: Three Byte (00000-7FFFF)
* F8-FF: Reserved (Longer instructions)

Core Bin Ops (Int/Long)
*  0, ADD
*  1, SUB
*  2, MUL
*  3, AND
*  4, OR
*  5, XOR
*  6, SHL (Shift Left)
*  7, SAR (Arithmetic Shift Right)

Ext Bin Ops (Int/Long)
*  8, SHR (Logical Shift Right)
*  9, DIV (Integer Divide)
*  A, MOD (Integer Modulo)
*  B, UMUL (Unsigned Multiply, Low Bits)
*  C, UMULH (Unsigned Multiply, High Bits)
*  D, UDIV (Unsigned Divide)

Core Bin Ops (Float/Double)
*  0, ADD
*  1, SUB
*  2, MUL
*  3, DIV

Compare Ops:
*  0, EQ
*  1, NE
*  2, LT
*  3, GT
*  4, LE
*  5, GE
*  6, EQQ
*  7, NEQ

Operation Type (Z)
*	0, Int
*	1, Long
*	2, Float
*	3, Double
*	4, Address
*	5, UInt
*	6, UByte
*	7, Short
*	8, SByte
*	9, UShort
*	A, ULong
*	B, Special Value, or Void
*	C, NLong
*	D, UNLong
*	E/F, Resv

X128 Operation Type (Z)
*  0, Int (4I)
*  1, Long (2L)
*  2, Float (4F)
*  3, Double (2D)
*  4, Int (2I)
*  5, Float (2F)
*  6, Int (3I)
*  7, Float (3F)
*  8, Int128
*  9, UInt128
*  A, Float128

X128 Binary Operators
*  Int128: Same as for other Int types.
*  Float128: Same as for other Float types.
*  Int Vec: Int operation applied to each element.
*  Float Vec:
**  0, ADD
**  1, SUB
**  2, MUL
**  3, DIV
**  4, Dot Product
**  5, Cross Product
**  6, CMul or QMul (Vec2=Complex, Vec4=Quat)
**  7, CMul2 or QMul2 (Vec2=Complex, Vec4=Quat)

X128 Unary Operators
*  Int128: Same as for other Int types.
*  Float128: Same as for other Float types.
*  Int Vec: Int operation applied to each element.
*  Float Vec:
**   0, NEG (A=-A)
**   1, Rcp (A=1/A)
**   2, Sqrt (A=sqrt(A))
**   3, RSqrt (A=1/sqrt(A))
**   4, Length (A.a=sqrt(dot(A, A)))
**   5, Length^2 (A.a=dot(A, A))


Ix: Variable Index
*  00-7F, Variable 00-7F
*  80-BF, Variable 0080-3FFF

Jx: Variable Pair
*  00-7F, I (High  3), J (Low  4)
*  80-BF, I (High  7), J (Low  7)
*  C0-DF, I (High 10), J (Low 11)

Kx: Variable+Constant
*  00-7F, I (High  3), C (Low  4)
*  80-BF, I (High  5), C (Low  9)
*  C0-DF, I (High  8), C (Low 13)
*  E0-EF, I (High  8), C (Low 20)
*  F0-F7, I (High  8), C (Low 27)
*  F8-FB, I (High 10), C (Low 32)
*  FC/FD, I (High 10), C (Low 39)
*  FE   , I (High 12), C (Low 44)
*  FF   , I (High 12), C (Low 52)

Cx: Constant (Depends on Type)
*  Signed Int Types, Interpreted as a sign-folded VLI
*  Unsigned Int Types, Interpreted as a raw VLI
*  Float/Double, Fx
*  Address, VLI interpreted as constant pool index.
*  Special Value, Interpreted as a magic number.
**  00-7F
**  80-BF XX
**  C0-DF XX(x2)
**  E0-EF XX(x3)
**  F0-F7 XX(x4)
**  F8-FB XX(x5)
**  FC-FD XX(x6)
**  FE    XX(x7)
**  FF    XX(x8)

Ci: Constant Signed Integer
Cj: Constant Unsigned Integer

Fx: Variable Length Packed Float
* (Drop): Direct Coding:
*  00-7F XX, S.5.9
**    Float15 (Shave H-Float)
*  80-BF XX XX, S.8.13
*  C0-DF XX XX XX, S.8.20
**    Shave Float
*  E0-EF XX XX XX XX, S.11.24
*  F0-F7 XX XX XX XX XX, S.11.31
*  F8-FB XX XX XX XX XX XX, S.11.38
*  FC-FD XX XX XX XX XX XX XX, S.11.45
**    Shave Double
*  FE XX XX XX XX, Float32
*  FF XX XX XX XX XX XX XX XX, Double
* (New) Coded the same as Kx.
** First value encodes exponent.
** Second value encodes fractional bits.
** The mantissa is represented as an integer which is scaled by 2^e.

Gx: Global Index

Ax: Address
* Encoded as a Signed VLI
* The VLI encodes an offset relative to the end of the instruction.

Za: Type+Count
*  Used for arg lists, which use a basic RLE scheme.
*  A indicates how many args use this type.

Zi: Type+Local
* Consists of a VLI value with Z coded in the low 4 bits.
* The remaining bits encode the index of the local.

Zn: Type+Count / Type+Index

Zo: Type+Binary
Zc: Type+Compare

Zx: Type+Constant
* Consists of a VLI value with Z stuck in the 4 low bits.
*  Likewise, the type determines the interpretation of the value.
** Float/Double
** Zx value encodes exponent.
** Another VLI follows encoding the mantissa bits.

Zx: Z=Special Value:
*  0, null (A)
*  1, undefined (A)
*  2, true (A)
*  3, false (A)
*  4, this (A)

Zy: Type+Constant (Variant)
* I/L/F/D/UI/UL: Interpreted as in Zx, just target type is variant.

NACHO:
* Not Abstract Core, High Overhead
* These operations may either be really fast, or really slow.
* Efficient implementation requires a considerable code-size overhead.
* Implementing them naively requires a notable runtime overhead.
** Baseline compilers should not use these operations.

NACHO2:
* Not Abstract Core, High Overhead
* These operations are implicitly high overhead.
* However, they may be the only reasonable way to perform the operation.


Instructions
* 00, ADDI			//A B => A+B
* 01, SUBI			//A B => A-B
* 02, MULI			//A B => A*B
* 03, ANDI			//A B => A&B
* 04, ORI			//A B => A|B
* 05, XORI			//A B => A^B
* 06, SHLI			//A B => A<<B
* 07, SARI			//A B => A>>B
* 08, ADDL			//A B => A+B
* 09, SUBL			//A B => A-B
* 0A, MULL			//A B => A*B
* 0B, ANDL			//A B => A&B
* 0C, ORL			//A B => A|B
* 0D, XORL			//A B => A^B
* 0E, SHLL			//A B => A<<B
* 0F, SARL			//A B => A>>B
* 10, ADDF			//A B => A+B
* 11, SUBF			//A B => A-B
* 12, MULF			//A B => A*B
* 13, DIVF			//A B => A/B
* 14, ADDD			//A B => A+B
* 15, SUBD			//A B => A-B
* 16, MULD			//A B => A*B
* 17, DIVD			//A B => A/B
** Perform basic arithmetic operations on a pair of stack items.
* 18, NEGI			//A => -A
* 19, NEGL			//A => -A
* 1A, NEGF			//A => -A
* 1B, NEGD			//A => -A
* 1C, NOTI			//A => ~A
* 1D, NOTL			//A => ~A
* 1E, LNTI			//A => !A
* 1F, LNTL			//A => !A
** Perform basic unary arithmetic ops.

* 20 Ix, LDI		// => A
* 21 Ix, LDL		// => A
* 22 Ix, LDF		// => A
* 23 Ix, LDD		// => A
* 24 Ix, STI		// A =>
* 25 Ix, STL		// A =>
* 26 Ix, STF		// A =>
* 27 Ix, STD		// A =>
* 28 Ix, LDA		// => A
* 29 Ix, STA		// A =>
** Load or store a local variable to/from the top of stack.

* 2A Zx, LDC		//Load Constant
** Load a constant encoded in Zx.

* 2B Jx, MVA		//MOV J to I
* 2C Jx, MVI		//MOV J to I
* 2D Jx, MVL		//MOV J to I
* 2E Jx, LVF		//MOV J to I
* 2F Jx, MVD		//MOV J to I
** Move a value between a pair of local variables.

* 30 Ax, JEQ		//Jump Equal ( (A==0) => )
* 31 Ax, JNE		//Jump Not-Equal ( (A!=0) => )
* 32 Ax, JLT		//Jump Less Than ( (A<0) => )
* 33 Ax, JGT		//Jump Greater Than ( (A>0) => )
* 34 Ax, JLE		//Jump Less Equal ( (A<=0) => )
* 35 Ax, JGE		//Jump Greater Equal ( (A>=0) => )
** Compare the item on the top of the stack with 0 and jump accordingly.
** The value is interpreted as an integer.

* 36 ZO Ax, JCMP	//Jump-Compare ( (A op B) =>)
** Compare two stack items and jump according to the operator.
** (NACHO).

* 37 Ax, JMP		//Jump
** Performs an unconditional jump.

* 38, CMPI			//Compare Int
* 39, CMPL			//Compare Long
* 3A, CMPF			//Compare Float
* 3B, CMPD			//Compare Double
* 3C, CMPA			//Compare Address (Logical)
* 3D, CMP2A			//Compare Address (Strict)
* 3E, CMP2F			//Compare Float (Unordered)
* 3F, CMP2D			//Compare Double (Unordered)

** Compare two stack items and push the result.
** These compare operations normally compare values, returning an integer:
*** -1, A&lt;B
***  0, A==B
***  1, A&gt;B

** If directly followed by a conditional jump, they will be special, and may be implicitly processed as a combined compare-and-jump operation.


* 40, LDIXI				//Load Index Int ( A I => B )
* 41, LDIXL				//Load Index Long ( A I => B )
* 42, LDIXF				//Load Index Float ( A I => B )
* 43, LDIXD				//Load Index Double ( A I => B )
* 44, STIXI				//Store Index Int ( V A I => )
* 45, STIXL				//Store Index Long ( V A I => )
* 46, STIXF				//Store Index Float ( V A I => )
* 47, STIXD				//Store Index Double ( V A I => )
* 48, LDIXSB				//Load Index Signed Byte ( A I => B )
* 49, LDIXUB				//Load Index Unsigned Byte ( A I => B )
* 4A, LDIXSS				//Load Index Signed Short ( A I => B )
* 4B, LDIXUS				//Load Index Unsigned Short ( A I => B )
* 4C, LDIXA				//Load Index Address ( A I => B )
* 4D, STIXA				//Store Index Address ( V A I => )
* 4E, STIXB				//Store Index Byte ( V A I => )
* 4F, STIXS				//Store Index Short ( V A I => )

** Load/Store Array Index, given as a signed integer.

* 50 Ci, LDIXIC			//Load Index Int ( I; A => B )
* 51 Ci, LDIXLC			//Load Index Long ( I; A => B )
* 52 Ci, LDIXFC			//Load Index Float ( I; A => B )
* 53 Ci, LDIXDC			//Load Index Double ( I; A => B )
* 54 Ci, STIXIC			//Store Index Int ( I; V A => )
* 55 Ci, STIXLC			//Store Index Long ( I; V A => )
* 56 Ci, STIXFC			//Store Index Float ( I; V A => )
* 57 Ci, STIXDC			//Store Index Double ( I; V A => )
* 58 Ci, LDIXSBC			//Load Index Signed Byte ( I; A => B )
* 59 Ci, LDIXUBC			//Load Index Unsigned Byte ( I; A => B )
* 5A Ci, LDIXSSC			//Load Index Signed Short ( I; A => B )
* 5B Ci, LDIXUSC			//Load Index Unsigned Short ( I; A => B )
* 5C Ci, LDIXAC			//Load Index Address ( I; A => B )
* 5D Ci, STIXAC			//Store Index Address ( I; V A => )
* 5E Ci, STIXBC			//Store Index Byte ( I; V A => )
* 5F Ci, STIXSC			//Store Index Short ( I; V A => )

** Load/Store Array Index using constant, given as a signed integer constant.
** Note that for many types of arrays, indices may be negative.

* 60 ZO, BINOP			//Binary Operator
* 61 ZO, CMPOP			//Compare Operator
* 62 ZO Ix, BINOPL		//Binary Operator (A op I)
* 63 ZO Ix, CMPOPL		//Compare Operator (A op I)
* 64 ZO Jx, BINOPLL		//Binary Operator (I op J)
* 65 ZO Jx, CMPOPLL		//Compare Operator (I op J)
* 66 ZO Cx, BINOPC		//Binary Operator (A op C)
* 67 ZO Kx, BINOPLC		//Binary Operator (I op C)
* 68 ZO Cx, CMPOPC		//Compare Operator (A op C)
* 69 ZO Kx, CMPOPLC		//Compare Operator (I op C)

** (NACHO).
** Compare operators will perform a comparison, returning a boolean value (0=false, 1=true).

* 6A Zn, PUSHN				//Push n Items (null/zero)
* 6B Zn, POPN				//Pop n Items
* 6C Zn, SWAPN				//Swap top-of-stack with Item n
* 6D Zn, ROTLN				//Rotate Left 1 position over n items.
* 6E Zn, ROTRN				//Rotate Right 1 position over n items.
* 6F Zn, DUPN				//Duplicate Top n items.
** (NACHO).

** Stack operations. May work on groups of items.
** The items are required to be of the base type given by Z.

* 70 Gx, CALLG			//Call Static/Global Function
* 71 Gx, CALLA			//Call Function Reference (Pops Func)
* 72 Gx, CALLV			//Call Virtual Method (Pops Obj)
* 73 Gx Ix, CALLL		//Call Local Function Reference

** These call operations use fixed argument lists. The argument list comes from the signature of the referenced global. This is either a function or a function prototype.

** The object or reference is pushed first, followed by args.
** Function arguments are pushed in left-to-right order.

* 74, RETI				//Return Int
* 75, RETL				//Return Long
* 76, RETF				//Return Float
* 77, RETD				//Return Double
* 78, RETA				//Return Address
* 79, RETV				//Return Void

** Return a value of a given type. The value is popped from the stack.
** As with unconditional jumps, the stack is assumed empty following a return instruction.

* 7A Zi, RET2				//Return Local

** Return a value from a local variable.

* 7B, LABEL				//Break the current trace

** This allows a jump to the instruction directly following the LABEL instruction. All paths which may arrive at this label are required to have the same stack layout. This also applies to the case where control simply passes through a label.

** LABEL is not required if directly following instructions which implicitly end the prior trace (such as calls, jumps, or return instructions).


* 7C Gx, LDOS				//Load Instance Variable, ( O => A )
* 7D Gx, STOS				//Store Instance Variable ( V O => )
* 7E Gx, LDGS				//Load Global Variable, ( => A )
* 7F Gx, STGS				//Store Global Variable ( V => )

** Load/Store variables.
** OS expects and object, and references a description of the object field.
** GS instead references the variable to be loaded/stored.

* 80 Zi, LDRL				//Load Ref To Local
* 81 Gx, LDROS				//Load Ref to Instance Variable, ( O => A )
* 82 Gx, LDRGS				//Load Ref to Global Variable, ( => A )
* 83 Zi, LDRLX				//Load Ref To Lexical

** Load a reference to a variable. This reference is only valid while the variable is in scope. The reference may be accessed as a single element array of the same type as the variable.
** Normally, the reference will be to the base type, rather than the canonical type.
** As a result, for example, a reference to a byte variable will be passed as a reference to int.

* 84 Zi, LDLX				//Load Lexical
* 85 Zi, STLX				//Store Lexical
* 86 Zn, DCLX				//Declare Lexical Variables
* 87 Zn, DELX				//Delete Lexical Variables
** Manage lexical environment.
** In this VM, the lexical environment will behave as a stack of variables with relative indices.

* 88 Gx, NEWOBJ				//Create object instance.
* 89 Zn, NEWARR				//Create array instance.
** n>0: n encodes array size.
** n==0: Use array size integer off stack.

* 8A, DELETE				//Delete object or array instance.
* 8B, DELNGBL				//Delete if not global.

* 8C, MOVOBJ				//Copy object contents ( A B => )
* 8D, MOVARR				//Copy array contents ( A B => )

* 8E, INCREF				//Increment object reference count ( A => A )
* 8F, DECREF				//Decrement object reference count ( A => A )
** Adjust reference counts.
** If reference counting is used, it is managed explicitly by the language.
** Similar applies to the handling of value types.

* 90, CVTI2L				//Convert Int->Long
* 91, CVTI2F				//Convert Int->Float
* 92, CVTI2D				//Convert Int->Double
* 93, CVTL2I				//Convert Long->Int
* 94, CVTL2F				//Convert Long->Float
* 95, CVTL2D				//Convert Long->Double
* 96, CVTF2I				//Convert Float->Int
* 97, CVTF2L				//Convert Float->Long
* 98, CVTF2D				//Convert Float->Double
* 99, CVTD2I				//Convert Double->Int
* 9A, CVTD2L				//Convert Double->Long
* 9B, CVTD2F				//Convert Double->Float
** Convert between types.

* 9C, CVTSB2I				//Convert SByte->Int
* 9D, CVTUB2I				//Convert UByte->Int
* 9E, CVTSS2I				//Convert Short->Int
* 9F, CVTUS2I				//Convert UShort->Int
** Sign or zero extend value to the wider size.

* A0, POPI				//Pop Int
* A1, POPL				//Pop Long
* A2, POPF				//Pop Float
* A3, POPD				//Pop Double
* A4, DUPI				//Duplicate Int
* A5, DUPL				//Duplicate Long
* A6, DUPF				//Duplicate Float
* A7, DUPD				//Duplicate Double
* A8, POPA				//Pop Address
* A9, DUPA				//Dup Address
* AA, SWAPA				//Swap Address
* AB, PUSHA				//Push Address null
* AC, PUSHI				//Push Int 0
* AD, PUSHL				//Push Long 0
* AE, PUSHF				//Push Float 0.0
* AF, PUSHD				//Push Double 0.0
** Perform type-specific stack operations on a single item.

* B0 Cj, ADDIC		//A B => A+C
* B1 Cj, SUBIC		//A B => A-C
* B2 Ci, MULIC		//A B => A*C
* B3 Ci, ANDIC		//A B => A&C
* B4 Ci, ORIC			//A B => A|C
* B5 Ci, XORIC		//A B => A^C
* B6 Ci, SHLIC		//A B => A<<C, A>>>(-C)
* B7 Ci, SARIC		//A B => A>>C
* B8 Ix, ADDIL		//A B => A+I
* B9 Ix, SUBIL		//A B => A-I
* BA Ix, MULIL		//A B => A*I
* BB Ix, ANDIL		//A B => A&I
* BC Ix, ORIL			//A B => A|I
* BD Ix, XORIL		//A B => A^I
* BE Ix, SHLIL		//A B => A<<I
* BF Ix, SARIL		//A B => A>>I
** Integer arithmetic operations with between a stack item and a constant or local.

* C0, HNOEX			//Non-Execute, Trace
* C1, HNOEX1		//Non-Execute, 1 Op
* C2, HNOEX2		//Non-Execute, 2 Ops
* C3, HNOEX3		//Non-Execute, 3 Ops
** These indicate that the following instructions are unreachable.
** It is invalid for any control-flow path to target a NOEX or its ops.
** HNOEX indicates a non-executable sequence terminated by a LABEL.
** HNOEX1..HNOEX3 indicate 1-3 non-executable instructions.
*** A new trace will be started following these instructions.
** Only a small subset of opcodes will be allowed in NOEX blocks.
*** Its intent is mostly to be used for stack manipulation.

* C4 Zx, RETC			//Return Constant

* C6, UCMPI				//Unsigned Compare Int
* C7, UCMPL				//Unsigned Compare Long
* C8 Cx, CMPIC			//Compare Int Const
* C9 Ix, CMPIL			//Compare Int Local
* CA Kx, CMPILC			//Compare Int Local Const
* CB Jx, CMPILL			//Compare Int Local Local

* CC, INCI				//Increment Integer ( A => A+1 )
* CD, DECI				//Decrement Integer ( A => A-1 )
* CE Ix, INCIL			//Increment Integer Local ( I++; )
* CF Ix, DECIL			//Decrement Integer Local ( I--; )

* E1 00, ADDAA			//Variant Add
* E1 01, SUBAA			//Variant Subtract
* E1 02, MULAA			//Variant Multiply
* E1 03, ANDAA			//Variant And
* E1 04, ORAA			//Variant Or
* E1 05, XORAA			//Variant Xor
* E1 06, SHLAA			//Variant Shl
* E1 07, SARAA			//Variant Sar
* E1 08, SHRAA			//Variant Shr
* E1 09, DIVAA			//Variant Divide
* E1 0A, MODAA			//Variant Modulo
* E1 0B, NEGAA			//Variant Negate
* E1 0C, NOTAA			//Variant Not
* E1 0D, LNTAA			//Variant LNot
** Arithmetic operations on variant.

* E1 0E, CMPAA			//Variant Compare
** Compare two variant values resulting in an integer.

* E1 0F Zx, LDCA		//Load Constant As Variant
** Load Constant as Variant
** Int/Load/Float/Double/UInt/ULong: Load variant constant.
** Address, load as type.
** SByte(8): Narrow String (ASCII/8859-1)
** UByte(6): Narrow String (UTF-8)
** Short(7): Wide String.

* E1 10, CVTI2AA		//Convert Int->Variant
* E1 11, CVTL2AA		//Convert Long->Variant
* E1 12, CVTF2AA		//Convert Float->Variant
* E1 13, CVTD2AA		//Convert Double->Variant
** Convert base types to variant.

* E1 14, CVTAA2I		//Convert Variant->Int
* E1 15, CVTAA2L		//Convert Variant->Long
* E1 16, CVTAA2F		//Convert Variant->Float
* E1 17, CVTAA2D		//Convert Variant->Double
** Convert variant to base types.
** Invalid conversions will result in a value of 0.

* E1 18, CVTAA2IN		//Convert Variant->Int (Strict)
* E1 19, CVTAA2LN		//Convert Variant->Long (Strict)
* E1 1A, CVTAA2FN		//Convert Variant->Float (Strict)
* E1 1B, CVTAA2DN		//Convert Variant->Double (Strict)
** Convert variant to base types (strict).
** Invalid conversions will throw an exception.

* E1 1C Kx, MVIC		//MOV C to I
* E1 1D Kx, MVLC		//MOV C to I
* E1 1E Kx, LVFC		//MOV C to I
* E1 1F Kx, MVDC		//MOV C to I
** Move a constant to a local variable.

* E1 20 Gx, LDTHIS		//Load This Variable, ( => A )
* E1 21 Gx, STTHIS		//Store This Variable ( V => )
** Load/Store an instance variable from 'this'.
** These ops may not be used in global functions or static methods.

* E1 22 Gx, CALLTH		//Call This Method
** Calls a virtual method from 'this'.

* E1 23 Cx, DCMPIC		//Dup+Compare Int Const

* E1 24 Cx Ax, DCJEQIC	//DUPI+CMPIC+JEQ
* E1 25 Cx Ax, DCJNEIC	//DUPI+CMPIC+JNE
* E1 26 Cx Ax, DCJLTIC	//DUPI+CMPIC+JLT
* E1 27 Cx Ax, DCJGTIC	//DUPI+CMPIC+JGT
* E1 28 Cx Ax, DCJLEIC	//DUPI+CMPIC+JLE
* E1 29 Cx Ax, DCJGEIC	//DUPI+CMPIC+JGE
** Duplicate int, compare int with a constant, and jump if condition is true.

* E1 2A Cx Ax, CJEQIC	//CMPIC+JEQ
* E1 2B Cx Ax, CJNEIC	//CMPIC+JNE
* E1 2C Cx Ax, CJLTIC	//CMPIC+JLT
* E1 2D Cx Ax, CJGTIC	//CMPIC+JGT
* E1 2E Cx Ax, CJLEIC	//CMPIC+JLE
* E1 2F Cx Ax, CJGEIC	//CMPIC+JGE
** Compare int with a constant and jump if condition is true.

* E1 30, LEARI			//Offset Array, Int ( A I => B )
* E1 31, LEARL			//Offset Array, Long ( A I => B )
* E1 32, LEARF			//Offset Array, Float ( A I => B )
* E1 33, LEARD			//Offset Array, Double ( A I => B )
* E1 34, LEARA			//Offset Array, Address ( A I => B )
* E1 35, LEARB			//Offset Array, Byte ( A I => B )
* E1 36, LEARS			//Offset Array, Short ( A I => B )
* E1 37, LEAST			//Offset String ( A I => B )
* E1 38 Ci, LEARIC		//Offset Array, Int ( I; A => B )
* E1 39 Ci, LEARLC		//Offset Array, Long ( I; A => B )
* E1 3A Ci, LEARFC		//Offset Array, Float ( I; A => B )
* E1 3B Ci, LEARDC		//Offset Array, Double ( I; A => B )
* E1 3C Ci, LEARAC		//Offset Array, Address ( I; A => B )
* E1 3D Ci, LEARBC		//Offset Array, Byte ( I; A => B )
* E1 3E Ci, LEARSC		//Offset Array, Short ( I; A => B )
* E1 3F Ci, LEASTC		//Offset String ( I; A => B )
** These are used to offset an array.
** Result is a new array which maps to an offset version of the old array.
** Writes to the new array are reflected in the old array.
** Accesses are required to be within the bounds of the original array.

* E1 40 Ix Gx, IFXOBJ		//Init Fixed Object (Struct)
* E1 41 Ix Zn, IFXARR		//Init Fixed Array
* E1 42 Ix Gx, DFXOBJ		//Deinit Fixed Object (Struct)
* E1 43 Ix Zn, DFXARR		//Deinit Fixed Array
** Init and Deinit fixed objects.
** These are used for structs and fixed arrays stored in local variables.
** These are not used for class instances (which use NEWOBJ/DELETE).

* E1 44, LBLCLNP			//Cleanup Label
** Declare a label which indicates the start of the cleanup sequence.
** This may implicitly do a noex-push of the return type.
** All jumps to this label are assumed to have the return value on the stack.
** The cleanup sequence is optional, and not present if no cleanup is needed.
** This may only appear at most once per function block.
** The cleanup sequence may not loop or branch.

* E1 45 Zn Cx, STIXNC			//Store Index Constant ( I, J; A => )
* E1 46 Zn Cx, DSTIXNC			//Dup Store Index Constant ( I, J; A => A )
* E1 47, NEWDYO					//New Dynamic Object
* E1 48 Gx, SBOS				//Bind Object Slot ( O V => )
* E1 49 Gx, DSBOS				//Dup Bind Object Slot ( O V => O )
* E1 4A Gx, DSTOS				//Dup Store Object Slot ( O V => )

* E1 4B Ix Gx, IFXOBJA			//Init Fixed Object Argument
** This is used to initialize incomming struct arguments.
** This is required prior to any mutable operations on the structure.
** This may be omitted if no mutable operations are performed.
** Note that IFXOBJA/DFXOBJ are paired, so either both or neither are used.

* E1 4C Zi, LDDRAL				//Load Deref Array Local
* E1 4D Zi, LDDRVL				//Load Deref VarRef Local
* E1 4E Zi, STDRAL				//Store Deref Array Local
* E1 4F Zi, STDRVL				//Store Deref VarRef Local
** Load or Store from Array or VarRef in Local.
* E1 50, LDDRI					//Load Deref Array Int ( R => V )
* E1 51, LDDRL					//Load Deref Array Long ( R => V )
* E1 52, LDDRF					//Load Deref Array Float ( R => V )
* E1 53, LDDRD					//Load Deref Array Double ( R => V )
* E1 54, STDRI					//Store Deref Array Int ( V R => )
* E1 55, STDRL					//Store Deref Array Long ( V R => )
* E1 56, STDRF					//Store Deref Array Float ( V R => )
* E1 57, STDRD					//Store Deref Array Double ( V R => )
* E1 58, LDDRSB					//Load Deref Array Int ( R => V )
* E1 59, LDDRUB					//Load Deref Array Int ( R => V )
* E1 5A, LDDRSS					//Load Deref Array Int ( R => V )
* E1 5B, LDDRUS					//Load Deref Array Int ( R => V )
* E1 5C, LDDRA					//Load Deref Array Address
* E1 5D, STDRA					//Store Deref Array Address
* E1 5E, STDRB					//Store Deref Array Address
* E1 5F, STDRS					//Store Deref Array Address
** Load/Store values from Arrays or Pointers.
** These operations may also be used on VarRefs.
** However, LDIX/STIX may not be used on VarRefs.


Vector operations (NACHO2):
* E1 60, MKX4I					//Make X128 From 4 Integers ( A B C D -> X )
* E1 61, MKX2L					//Make X128 From 2 Longs ( AB CD -> X )
* E1 62, MKX4F					//Make X128 From 4 Floats ( A B C D -> X )
* E1 63, MKX2D					//Make X128 From 2 Doubles ( AB CD -> X )
** Make X128 from component values.
** Int128 or Float128 values may be made using 4I or 2L.
* E1 64, DUPX					//DUP X128
* E1 65, POPX					//POP X128
** These are required for X128 values, rather than DUPA/POPA.
* E1 66 Ix, LDXL				//Load X128 From Local
* E1 67 Ix, STXL				//Store X128 To Local
** Load or store X128 value from local.
** May copy value as needed.
* E1 68 Ix, IFXX				//Init X128
* E1 69 Ix, DFXX				//Deinit X128
* E1 6A Ix, IFXXA				//Init X128 Argument
** These are similar in use to fixed-object ops.
* E1 6B Zn, LDXX				//Load X Element ( X -> A )
* E1 6C Zn, DLDXX				//Dup Load X Element ( X -> X A )
** Z gives element type, and n gives index.
* E1 6D Zn, STXX				//Store X Element ( X A -> Y )
** Store an element, resulting in a new X128.
* E1 6E ZO, BINOPX				//Binary Operator ( A B -> C )
* E1 6F ZO, UNOPX				//Unary Operator ( A -> C )
** Apply binary operators to vectors.
** Not all operators are defined for all vector types.
** Some operators may have different behavior.

Vector convert operations (NACHO2):
* E1 70, CVTI2XL				//Convert Int to Int128 (Sign Extend)
* E1 71, CVTL2XL				//Convert Long to Int128 (Sign Extend)
* E1 72, CVTUI2XL				//Convert UInt to Int128 (Zero Extend)
* E1 73, CVTUL2XL				//Convert ULong to Int128 (Zero Extend)
* E1 74, CVTXL2I				//Convert Int128 to Int (Truncate)
* E1 75, CVTXL2L				//Convert Int128 to Long (Truncate)
* E1 76, CVTD2XF				//Convert Double to Float128
* E1 77, CVTXF2D				//Convert Float128 to Double
* E1 78, CVTXL2XF				//Convert Int128 to Float128
* E1 79, CVTXF2XL				//Convert Float128 to Int128
* E1 7A, CVTXL2AA				//Convert Int128 to Variant
* E1 7B, CVTXF2AA				//Convert Float128 to Variant
* E1 7C, CVTAA2XL				//Convert Variant to Int128
* E1 7D, CVTAA2XF				//Convert Variant to Float128

More Array ops:
* E1 7E Zi Ix, LDIXZLL		//Store Index Local-Local (A, I; => V )
* E1 7F Zi Ci, LDIXZLC		//Store Index Local-Const (A, C; => V )
** Load Index from Locals

* E1 80, RSTIXI				//Store Index Int ( A I V => )
* E1 81, RSTIXL				//Store Index Long ( A I V => )
* E1 82, RSTIXF				//Store Index Float ( A I V => )
* E1 83, RSTIXD				//Store Index Double ( A I V => )
* E1 84, RSTIXA				//Store Index Address ( A I V => )
* E1 85, RSTIXB				//Store Index Byte ( A I V => )
* E1 86, RSTIXS				//Store Index Short ( A I V => )
* E1 87 Zi Ix, STIXZLL		//Store Index Local-Local (A, I; V => )
* E1 88 Ci, RSTIXIC			//Store Index Int ( I; A V => )
* E1 89 Ci, RSTIXLC			//Store Index Long ( I; A V => )
* E1 8A Ci, RSTIXFC			//Store Index Float ( I; A V => )
* E1 8B Ci, RSTIXDC			//Store Index Double ( I; A V => )
* E1 8C Ci, RSTIXAC			//Store Index Address ( I; A V => )
* E1 8D Ci, RSTIXBC			//Store Index Byte ( I; A V => )
* E1 8E Ci, RSTIXSC			//Store Index Short ( I; A V => )
* E1 8F Zi Ci, STIXZLC		//Store Index Local-Const (A, C; V => )
** RSTIX=Reverse Store Index
** Basically the same as normal store index, but with ordering swapped.
** STIXZL*=Store Index with locals.

* E1 90, CVTAA2ST			//Convert Variant to String
* E1 91, CVTST2AA			//Convert String to Variant
** Convert between string and variant.
** Most other types will be converted through variant.

* E1 92, CATST				//Append two strings.
* E1 93, CMPST				//Compare two strings.
** Strings are compared exactly (by byte or character value).
** Results are undefined if comparing strings of different types.

* E1 94, CMPSST				//Compare two strings (case sensitive).
* E1 95, CMPUST				//Compare two strings (case insensitive).
** Strings are compared in terms of codepoint values.
** Case insensitive comparisons will map lower-case code-points to their upper-case equivalents.
** No mapping will be performed if the codepoint lacks a direct upper-case equivalent, or if case is not applicable.

* E1 96 Zn, MATHUFN
** Math Unary Function
** 0=Sin, 1=Cos, 2=Tan, 3=Sqrt, ...

* E1 97 Zn, MATHBFN
** Math Binary Function
** 0=Atan2

* E1 98 Ix Gx, STFXOBJC				//Store Fixed Object (Copy)
* E1 99 Ix Gx, STFXOBJD				//Store Fixed Object (Destroy)

* E1 9A Zn, STIXZAC					//CVTZ2AA+STIXAC
* E1 9B Zn, DSTIXZAC				//DUPA+CVTZ2AA+STIXAC

* E1 9C Ax, JEQNULL					//Jump If Null
* E1 9D Ax, JNENULL					//Jump If Not Null
* E1 9E Ix Ax, JEQNULLL				//Jump If Null (Local)
* E1 9F Ix Ax, JNENULLL				//Jump If Not Null (Local)
