BSVM 2-1 Bytecode.

Model:
  Args/Locals
  Stack
  Lexical
  ...
  
Like JVM, Args will be locals 1-N, with local variables following args.

Alternately, could have locals first, followed by args. Reason: on average locals are used more than args, so this could lead to better code density, and deals better with variable argument lists.

Stack
All instructions at a given location will be required to have the same stack layout (depth and types) at all possible control paths. Values may be left on the stack during jumps, provided:
Both the start and destination have the same layout;
The layout for a label matches what it would be if control arrived via the preceding instruction.

Unconditional jumps will behave as-if all items have been popped from the stack.

 LDI src			//load integer (local->stack)
 STI dst			//store integer (stack->local)
 MVI dst, src	//move integer (local->local)
 ADDI			//A B => A+B
 ADDIL src		//A => A+src
 ADDIC const		//A => A+const

Core Types:
  I, Int (Int32, UInt32)
  L, Long
  F, Float
  D, Double
  A, Address

Sub-Types:
  Int
    byte/sbyte/ubyte
    short/ushort
    int/uint
    char (16 bit, in storage)
    char8 (8 bit)
  Long
    long/ulong (64 bit)
    nlong/unlong (32 or 64 bit, non-core storage)
  Float
    float
    hfloat (16-bit in storage)
  Double
    double
  Address
    object
    array
    pointer
    variant
    string
    reference
    ...

Implementation may treat arrays and pointers as siblings, both existing nominally as an offset relative to a base object. This base object will nominally be an array.

A pointer will then exist as a type of special Null-Array, which extends over the entire address space.

Normally, the address will need to track what type it is. Addresses in this VM will generally not be raw pointers.

Logical comparison of an address values will depend on the type of objects involved. Strict comparisons will compare the bit patterns.


Strings will be treated as immutable character arrays. Normal strings will be either narrow (8859-1) or wide (UCS-2 / UTF-16). As a variable, char will be represented as a signed 32-bit integer, however its storage in strings or arrays will be narrower. In arrays, char will be represented as an unsigned short.

Both objects and arrays may have reference counts. If the reference count for an object becomes 0, it is freed implicitly. Objects and arrays may also be copied to implement pass-by-value semantics, however, this will be managed primarily by the language and not by the VM.

The handling of reference counting will be explicit in the bytecode.

Copying between arrays or objects will require both to be the same type and size.


Native Long will be a non-core type which will primarily effect its storage size. It will be treated as a 64-bit long type in the bytecode.

Narrower types will implicitly widen to their parent core type, with the narrower type primarily effecting storage. As a result, intermediate arithmetic results may reflect the wider type.


Signature Characters:
*  a, sbyte (signed byte)
*  b, bool (byte)
*  c, char8
*  d, double
*  e, (long double)
*  f, float
*  g, float128
*  h, ubyte (unsigned byte)
*  i, int
*  j, uint
*  k, float16
*  l, native long
*  m, native ulong
*  n, int128
*  o, uint128
*  p, 
*  q, 
*  r, variant
*  s, short
*  t, ushort
*  u,
*  v, void
*  w, char (16-bit)
*  x, long
*  y, ulong
*  z, vararg (array of remaining arguments)
*  Cs, string
*  R*, Reference
*  P*, Pointer
*  Q*, Array (array reference)
*  X(id), struct (inline value object)
*  L(id), class or interface (object reference)
*  U(id), extended non-core types.

Function/Method signatures:
*  (args*)ret*
*  int foo(float x, double y);
** Would have the signature: "(fd)i"

For X and L, the id may be either a number or a Qname. Ex: "L1234" means the class at entry 1234, whereas "Lfoo/bar/baz;" gives a QName.


== Constant Pool ==

This will be done indirectly for bytecode.
Namely, the function or method will refer to a block-local table, which will hold indices into an image-level constant pool.


== Instruction Set ==

* 00-DF: Single Byte
* E0-EF: Two Byte (0000-0FFF)
* F0-F7: Three Byte (00000-7FFFF)
* F8-FF: Reserved (Longer instructions)

Core Bin Ops (Int/Long)
*  0, ADD
*  1, SUB
*  2, MUL
*  3, AND
*  4, OR
*  5, XOR
*  6, SHL (Shift Left)
*  7, SAR (Arithmetic Shift Right)
Ext Bin Ops (Int/Long)
*  8, SHR (Logical Shift Right)
*  9, DIV (Integer Divide)
*  A, MOD (Integer Modulo)
*  B, UMUL (Unsigned Multiply, Low Bits)
*  C, UMULH (Unsigned Multiply, High Bits)
*  D, UDIV (Unsigned Divide)

Core Bin Ops (Float/Double)
*  0, ADD
*  1, SUB
*  2, MUL
*  3, DIV

Compare Ops:
*  0, EQ
*  1, NE
*  2, LT
*  3, GT
*  4, LE
*  5, GE
*  6, EQQ
*  7, NEQ

Operation Type (Z)
*	0, Int
*	1, Long
*	2, Float
*	3, Double
*	4, Address
*	5, UInt
*	6, UByte
*	7, Short
*	8, SByte
*	9, UShort
*	A, ULong
*	B, Special Value, or Void
*	C-F, Resv

Ix: Variable Index
*  00-7F, Variable 00-7F
*  80-BF, Variable 0080-3FFF

Jx: Variable Pair
*  00-7F, I (High  3), J (Low  4)
*  80-BF, I (High  7), J (Low  7)
*  C0-DF, I (High 10), J (Low 11)

Kx: Variable+Constant
*  00-7F, I (High  3), C (Low  4)
*  80-BF, I (High  5), C (Low  9)
*  C0-DF, I (High  8), C (Low 13)
*  E0-EF, I (High  8), C (Low 20)
*  F0-F7, I (High  8), C (Low 27)
*  F8-FB, I (High 10), C (Low 32)
*  FC/FD, I (High 10), C (Low 39)
*  FE   , I (High 12), C (Low 44)
*  FF   , I (High 12), C (Low 52)

Cx: Constant (Depends on Type)
*  Signed Int Types, Interpreted as a sign-folded VLI
*  Unsigned Int Types, Interpreted as a raw VLI
*  Float/Double, Fx
*  Address, VLI interpreted as constant pool index.
*  Special Value, Interpreted as a magic number.
**  00-7F
**  80-BF XX
**  C0-DF XX(x2)
**  E0-EF XX(x3)
**  F0-F7 XX(x4)
**  F8-FB XX(x5)
**  FC-FD XX(x6)
**  FE    XX(x7)
**  FF    XX(x8)

Ci: Constant Signed Integer
Cj: Constant Unsigned Integer

Fx: Variable Length Packed Float
* (Drop): Direct Coding:
*  00-7F XX, S.5.9
**    Float15 (Shave H-Float)
*  80-BF XX XX, S.8.13
*  C0-DF XX XX XX, S.8.20
**    Shave Float
*  E0-EF XX XX XX XX, S.11.24
*  F0-F7 XX XX XX XX XX, S.11.31
*  F8-FB XX XX XX XX XX XX, S.11.38
*  FC-FD XX XX XX XX XX XX XX, S.11.45
**    Shave Double
*  FE XX XX XX XX, Float32
*  FF XX XX XX XX XX XX XX XX, Double
* (New) Coded the same as Kx.
** First value encodes exponent.
** Second value encodes fractional bits.
** The mantissa is represented as an integer which is scaled by 2^e.

Gx: Global Index

Ax: Address
* Encoded as a Signed VLI
* The VLI encodes an offset relative to the end of the instruction.

Za: Type+Count
*  Used for arg lists, which use a basic RLE scheme.
*  A indicates how many args use this type.

Zi: Type+Local
* Consists of a VLI value with Z coded in the low 4 bits.
* The remaining bits encode the index of the local.

Zn: Type+Count

Zo: Type+Binary
Zc: Type+Compare

Zx: Type+Constant
* Consists of a VLI value with Z stuck in the 4 low bits.
*  Likewise, the type determines the interpretation of the value.
** Float/Double
** Zx value encodes exponent.
** Another VLI follows encoding the mantissa bits.

Zx: Z=Special Value:
*  0, null (A)
*  1, undefined (A)
*  2, true (A)
*  3, false (A)
*  4, this (A)

Zy: Type+Constant (Variant)
* I/L/F/D/UI/UL: Interpreted as in Zx, just target type is variant.


Instructions
* 00, ADDI	//A B => A+B
* 01, SUBI	//A B => A-B
* 02, MULI	//A B => A*B
* 03, ANDI	//A B => A&B
* 04, ORI		//A B => A|B
* 05, XORI	//A B => A^B
* 06, SHLI	//A B => A<<B
* 07, SARI	//A B => A>>B
* 08, ADDL	//A B => A+B
* 09, SUBL	//A B => A-B
* 0A, MULL	//A B => A*B
* 0B, ANDL	//A B => A&B
* 0C, ORL		//A B => A|B
* 0D, XORL	//A B => A^B
* 0E, SHLL	//A B => A<<B
* 0F, SARL	//A B => A>>B
* 10, ADDF	//A B => A+B
* 11, SUBF	//A B => A-B
* 12, MULF	//A B => A*B
* 13, DIVF	//A B => A/B
* 14, ADDD	//A B => A+B
* 15, SUBD	//A B => A-B
* 16, MULD	//A B => A*B
* 17, DIVD	//A B => A/B
** Perform basic arithmetic operations on a pair of stack items.
* 18, NEGI	//A => -A
* 19, NEGL	//A => -A
* 1A, NEGF	//A => -A
* 1B, NEGD	//A => -A
* 1C, NOTI	//A => ~A
* 1D, NOTL	//A => ~A
* 1E, LNTI	//A => !A
* 1F, LNTL	//A => !A
** Perform basic unary arithmetic ops.

* 20 Ix, LDI		// => I
* 21 Ix, LDL		// => I
* 22 Ix, LDF		// => I
* 23 Ix, LDD		// => I
* 24 Ix, STI		// A =>
* 25 Ix, STL		// A =>
* 26 Ix, STF		// A =>
* 27 Ix, STD		// A =>
* 28 Ix, LDA		// => I
* 29 Ix, STA		// A =>
** Load or store a local variable to/from the top of stack.

* 2A Zx, LDC		//Load Constant
** Load a constant encoded in Zx.

* 2B Jx, MVA		//MOV J to I
* 2C Jx, MVI		//MOV J to I
* 2D Jx, MVL		//MOV J to I
* 2E Jx, LVF		//MOV J to I
* 2F Jx, MVD		//MOV J to I
** Move a value between a pair of local variables.

* 30 Ax, JEQ		//Jump Equal ( (A==0) => )
* 31 Ax, JNE		//Jump Not-Equal ( (A!=0) => )
* 32 Ax, JLT		//Jump Less Than ( (A<0) => )
* 33 Ax, JGT		//Jump Greater Than ( (A>0) => )
* 34 Ax, JLE		//Jump Less Equal ( (A<=0) => )
* 35 Ax, JGE		//Jump Greater Equal ( (A>=0) => )
** Compare the item on the top of the stack with 0 and jump accordingly.

* 36 ZO Ax, JCMP	//Jump-Compare ( (A op B) =>)
** Compare two stack items and jump according to the operator.

* 37 Ax, JMP		//Jump
** Performs an unconditional jump.

* 38, CMPI			//Compare Int
* 39, CMPL			//Compare Long
* 3A, CMPF			//Compare Float
* 3B, CMPD			//Compare Double
* 3C, CMPA			//Compare Address (Logical)
* 3D, CMP2A			//Compare Address (Strict)
* 3E, CMP2F			//Compare Float (Unordered)
* 3F, CMP2D			//Compare Double (Unordered)

** Compare two stack items and push the result.
** These compare operations normally compare values, returning an integer:
*** -1, A&lt;B
***  0, A==B
***  1, A&gt;B

** If directly followed by a conditional jump, they will be special, and may be implicitly processed as a combined compare-and-jump operation.


* 40, LDIXI				//Load Index Int ( A I => B )
* 41, LDIXL				//Load Index Long ( A I => B )
* 42, LDIXF				//Load Index Float ( A I => B )
* 43, LDIXD				//Load Index Double ( A I => B )
* 44, STIXI				//Store Index Int ( A I V => )
* 45, STIXL				//Store Index Long ( A I V => )
* 46, STIXF				//Store Index Float ( A I V => )
* 47, STIXD				//Store Index Double ( A I V => )
* 48, LDIXSB				//Load Index Signed Byte ( A I => B )
* 49, LDIXUB				//Load Index Unsigned Byte ( A I => B )
* 4A, LDIXSS				//Load Index Signed Short ( A I => B )
* 4B, LDIXUS				//Load Index Unsigned Short ( A I => B )
* 4C, LDIXA				//Load Index Address ( A I => B )
* 4D, STIXA				//Store Index Address ( A I V => )
* 4E, STIXB				//Store Index Byte ( A I V => )
* 4F, STIXS				//Store Index Short ( A I V => )

** Load/Store Array Index, given as a signed integer.

* 50 Cx, LDIXIC			//Load Index Int ( I; A => B )
* 51 Cx, LDIXLC			//Load Index Long ( I; A => B )
* 52 Cx, LDIXFC			//Load Index Float ( I; A => B )
* 53 Cx, LDIXDC			//Load Index Double ( I; A => B )
* 54 Cx, STIXIC			//Store Index Int ( I; A V => )
* 55 Cx, STIXLC			//Store Index Long ( I; A V => )
* 56 Cx, STIXFC			//Store Index Float ( I; A V => )
* 57 Cx, STIXDC			//Store Index Double ( I; A V => )
* 58 Cx, LDIXSBC			//Load Index Signed Byte ( I; A => B )
* 59 Cx, LDIXUBC			//Load Index Unsigned Byte ( I; A => B )
* 5A Cx, LDIXSSC			//Load Index Signed Short ( I; A => B )
* 5B Cx, LDIXUSC			//Load Index Unsigned Short ( I; A => B )
* 5C Cx, LDIXAC			//Load Index Address ( I; A => B )
* 5D Cx, STIXAC			//Store Index Address ( I; A V => )
* 5E Cx, STIXBC			//Store Index Byte ( I; A V => )
* 5F Cx, STIXSC			//Store Index Short ( I; A V => )

** Load/Store Array Index using constant, given as a signed integer constant.
** Note that for many types of arrays, indices may be negative.

* 60 ZO, BINOP			//Binary Operator
* 61 ZO, CMPOP			//Compare Operator
* 62 ZO Ix, BINOPL		//Binary Operator (A op I)
* 63 ZO Ix, CMPOPL		//Compare Operator (A op I)
* 64 ZO Jx, BINOPLL		//Binary Operator (I op J)
* 65 ZO Jx, CMPOPLL		//Compare Operator (I op J)
* 66 ZO Cx, BINOPC		//Binary Operator (A op C)
* 67 ZO Kx, BINOPLC	//Binary Operator (I op C)
* 68 ZO Cx, CMPOPC		//Compare Operator (A op C)
* 69 ZO Kx, CMPOPLC	//Compare Operator (I op C)

** Binary compare operators will perform a comparison, returning a boolean value (0=false, 1=true).

* 6A Zn, PUSHN				//Push n Items (null/zero)
* 6B Zn, POPN				//Pop n Items
* 6C Zn, SWAPN				//Swap top-of-stack with Item n
* 6D Zn, ROTLN				//Rotate Left 1 position over n items.
* 6E Zn, ROTRN				//Rotate Right 1 position over n items.
* 6F Zn, DUPN				//Duplicate Top n items.

** Stack operations. May work on groups of items.
** The items are required to be of the base type given by Z.

* 70 Gx, CALLG			//Call Static/Global Function
* 71 Gx, CALLA			//Call Function Reference (Pops Func)
* 72 Gx, CALLV			//Call Virtual Method (Pops Obj)
* 73 Gx Ix, CALLL		//Call Local Function Reference

** These call operations use fixed argument lists. The argument list comes from the signature of the referenced global. This is either a function or a function prototype.

* 74, RETI				//Return Int
* 75, RETL				//Return Long
* 76, RETF				//Return Float
* 77, RETD				//Return Double
* 78, RETA				//Return Address
* 79, RETV				//Return Void

** Return a value of a given type. The value is popped from the stack.
** As with unconditional jumps, the stack is assumed empty following a return instruction.

* 7A Zi, RET2				//Return Local

** Return a value from a local variable.

* 7B, LABEL				//Break the current trace

** This allows a jump to the instruction directly following the LABEL instruction. All paths which may arrive at this label are required to have the same stack layout. This also applies to the case where control simply passes through a label.

** LABEL is not required if directly following instructions which implicitly end the prior trace (such as calls, jumps, or return instructions).


* 7C Gx, LDOS				//Load Instance Variable, ( O => A )
* 7D Gx, STOS				//Store Instance Variable ( O V => )
* 7E Gx, LDGS				//Load Global Variable, ( => A )
* 7F Gx, STGS				//Store Global Variable ( V => )

** Load/Store variables.
** OS expects and object, and references a description of the object field.
** GS instead references the variable to be loaded/stored.

* 80 Ix, LDRL				//Load Ref To Local
* 81 Gx, LDROS			//Load Ref to Instance Variable, ( O => A )
* 82 Gx, LDRGS			//Load Ref to Global Variable, ( => A )
* 83 Ix, LDRLX				//Load Ref To Lexical

** Load a reference to a variable. This reference is only valid while the variable is in scope. The reference may be accessed as a single element array of the same type as the variable.
** Normally, the reference will be to the base type, rather than the canonical type.
** As a result, for example, a reference to a byte variable will be passed as a reference to int.

* 84 Zi, LDLX				//Load Lexical
* 85 Zi, STLX				//Store Lexical
* 86 Zn, DCLX				//Declare Lexical Variables
* 87 Zn, DELX				//Delete Lexical Variables
** Manage lexical environment.
** In this VM, the lexical environment will behave as a stack of variables with relative indices.

* 88 Gx, NEWOBJ				//Create object instance.
* 89 Zn, NEWARR				//Create array instance.
* 8A, DELETE				//Delete object or array instance.
* 8B, DELNGBL				//Delete if not global.

* 8C, MOVOBJ				//Copy object contents ( A B => )
* 8D, MOVARR				//Copy array contents ( A B => )

* 8E, INCREF				//Increment object reference count
* 8F, DECREF				//Decrement object reference count
** Adjust reference counts.
** If reference counting is used, it is managed explicitly by the language.
** Similar applies to the handling of value types.

* 90, CVTI2L				//Convert Int->Long
* 91, CVTI2F				//Convert Int->Float
* 92, CVTI2D				//Convert Int->Double
* 93, CVTL2I				//Convert Long->Int
* 94, CVTL2F				//Convert Long->Float
* 95, CVTL2D				//Convert Long->Double
* 96, CVTF2I				//Convert Float->Int
* 97, CVTF2L				//Convert Float->Long
* 98, CVTF2D				//Convert Float->Double
* 99, CVTD2I				//Convert Double->Int
* 9A, CVTD2L				//Convert Double->Long
* 9B, CVTD2F				//Convert Double->Float
* 9C, CVTSB2I				//Convert SByte->Int
* 9D, CVTUB2I				//Convert UByte->Int
* 9E, CVTSS2I				//Convert Short->Int
* 9F, CVTUS2I				//Convert UShort->Int
** Convert between types.

* A0, POPI				//Pop Int
* A1, POPL				//Pop Long
* A2, POPF				//Pop Float
* A3, POPD				//Pop Double
* A4, DUPI				//Duplicate Int
* A5, DUPL				//Duplicate Long
* A6, DUPF				//Duplicate Float
* A7, DUPD				//Duplicate Double
* A8, POPA				//Pop Address
* A9, DUPA				//Dup Address
* AA, SWAPA				//Swap Address
* AB, PUSHA				//Push Address null
* AC, PUSHI				//Push Int 0
* AD, PUSHL				//Push Long 0
* AE, PUSHF				//Push Float 0.0
* AF, PUSHD				//Push Double 0.0
** Perform type-specific stack operations on a single item.

* B0 Cj, ADDIC		//A B => A+C
* B1 Cj, SUBIC		//A B => A-C
* B2 Ci, MULIC		//A B => A*C
* B3 Ci, ANDIC		//A B => A&C
* B4 Ci, ORIC			//A B => A|C
* B5 Ci, XORIC		//A B => A^C
* B6 Ci, SHLIC		//A B => A<<C, A>>>(-C)
* B7 Ci, SARIC		//A B => A>>C
* B8 Ix, ADDIL		//A B => A+I
* B9 Ix, SUBIL		//A B => A-I
* BA Ix, MULIL		//A B => A*I
* BB Ix, ANDIL		//A B => A&I
* BC Ix, ORIL			//A B => A|I
* BD Ix, XORIL		//A B => A^I
* BE Ix, SHLIL		//A B => A<<I
* BF Ix, SARIL		//A B => A>>I
** Integer arithmetic operations with between a stack item and a constant or local.

* C0, HNOEX			//Non-Execute, Trace
* C1, HNOEX1		//Non-Execute, 1 Op
* C2, HNOEX2		//Non-Execute, 2 Ops
* C3, HNOEX3		//Non-Execute, 3 Ops
** These indicate that the following instructions are unreachable.
** It is invalid for any control-flow path to target a NOEX or its ops.
** HNOEX indicates a non-executable sequence terminated by a LABEL.
** HNOEX1..HNOEX3 indicate 1-3 non-executable instructions.
*** A new trace will be started following these instructions.

* C4 Zc, RETC			//Return Constant

* C6, UCMPI				//Unsigned Compare Int
* C7, UCMPL				//Unsigned Compare Long
* C8 Cx, CMPIC			//Compare Int Const
* C9 Ix, CMPIL			//Compare Int Local
* CA Kx, CMPILC			//Compare Int Local Const
* CB Jx, CMPILL			//Compare Int Local Local

* CC, INCI				//Increment Integer ( A => A+1 )
* CD, DECI				//Decrement Integer ( A => A-1 )
* CE Ix, INCIL			//Increment Integer Local ( I++; )
* CF Ix, DECIL			//Decrement Integer Local ( I--; )

* E1 00, ADDAA			//Variant Add
* E1 01, SUBAA			//Variant Subtract
* E1 02, MULAA			//Variant Multiply
* E1 03, ANDAA			//Variant And
* E1 04, ORAA			//Variant Or
* E1 05, XORAA			//Variant Xor
* E1 06, SHLAA			//Variant Shl
* E1 07, SARAA			//Variant Sar
* E1 08, SHRAA			//Variant Shr
* E1 09, DIVAA			//Variant Divide
* E1 0A, MODAA			//Variant Modulo
* E1 0B, NEGAA			//Variant Negate
* E1 0C, NOTAA			//Variant Not
* E1 0D, LNOTAA			//Variant LNot
** Arithmetic operations on variant.

* E1 0E, CMPAA			//Variant Compare
** Compare two variant values resulting in an integer.

* E1 0F Zx, LDCA		//Load Constant As Variant
** Load Constant as Variant
** Int/Load/Float/Double/UInt/ULong: Load variant constant.
** Address, load as type.
** SByte(8): Narrow String (ASCII/8859-1)
** UByte(6): Narrow String (UTF-8)
** Short(7): Wide String.

* E1 10, CVTI2AA		//Convert Int->Variant
* E1 11, CVTL2AA		//Convert Long->Variant
* E1 12, CVTF2AA		//Convert Float->Variant
* E1 13, CVTD2AA		//Convert Double->Variant
** Convert base types to variant.

* E1 14, CVTAA2I		//Convert Variant->Int
* E1 15, CVTAA2L		//Convert Variant->Long
* E1 16, CVTAA2F		//Convert Variant->Float
* E1 17, CVTAA2D		//Convert Variant->Double
** Convert variant to base types.
** Invalid conversions will result in a value of 0.

* E1 18, CVTAA2IN		//Convert Variant->Int (Strict)
* E1 19, CVTAA2LN		//Convert Variant->Long (Strict)
* E1 1A, CVTAA2FN		//Convert Variant->Float (Strict)
* E1 1B, CVTAA2DN		//Convert Variant->Double (Strict)
** Convert variant to base types (strict).
** Invalid conversions will throw an exception.

* E1 1C Kx, MVIC		//MOV C to I
* E1 1D Kx, MVLC		//MOV C to I
* E1 1E Kx, LVFC		//MOV C to I
* E1 1F Kx, MVDC		//MOV C to I
** Move a constant to a local variable.

* E1 20 Gx, LDTHIS		//Load This Variable, ( => A )
* E1 21 Gx, STTHIS		//Store This Variable ( V => )
** Load/Store an instance variable from 'this'.
** These ops may not be used in global functions or static methods.

* E1 22 Gx, CALLTH		//Call This Method
** Calls a virtual method from 'this'.

* E1 24 Cx, DCMPIC		//Dup+Compare Int Const
* E1 25 Cx Ax, DCJEQIC	//DUPI+CMPI+JEQ
* E1 26 Cx Ax, DCJLTIC	//DUPI+CMPI+JLT
* E1 27 Cx Ax, DCJGTIC	//DUPI+CMPI+JGT

