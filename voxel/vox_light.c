#include <bteifgl.h>

static const byte bgbdt_voxlight_blendtab[16*16]=
{
/*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */
/*0*/ 0x0,0x9,0xA,0xB,0xC,0xD,0xE,0xF,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 
/*1*/ 0x9,0x1,0x3,0x3,0x5,0x5,0x0,0x9,0x9,0x9,0xB,0xB,0xD,0xD,0x0,0x9,
/*2*/ 0xA,0x3,0x2,0x3,0x6,0x0,0x6,0xA,0xA,0xB,0xA,0x0,0xE,0x0,0xE,0xA,
/*3*/ 0xB,0x3,0x3,0x3,0x0,0x0,0x0,0xB,0xB,0xB,0xB,0xB,0x0,0x0,0x0,0xB,
/*4*/ 0xC,0x5,0x6,0x0,0x4,0x5,0x6,0xC,0xC,0xD,0xC,0x0,0xC,0xD,0xE,0xC,
/*5*/ 0xD,0x5,0x0,0x0,0x5,0x5,0x0,0xD,0xD,0xD,0x0,0x0,0xD,0xD,0x0,0xD,
/*6*/ 0xE,0x0,0x6,0x0,0x6,0x0,0x6,0xE,0xE,0x0,0xE,0x0,0xE,0x0,0xE,0xE,
/*7*/ 0xF,0x9,0xA,0xB,0xC,0xD,0xE,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xF,
/*8*/ 0x0,0x9,0xA,0xB,0xC,0xD,0xE,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0xF,
/*9*/ 0x0,0x9,0xB,0xB,0xD,0xD,0x0,0x0,0x0,0x9,0xB,0xB,0xD,0xD,0x0,0xF,
/*A*/ 0x0,0xB,0xA,0xB,0xC,0x0,0xE,0x0,0x0,0xE,0xA,0xB,0xE,0x0,0xE,0xF,
/*B*/ 0x0,0xB,0x0,0xB,0x0,0x0,0x0,0x0,0x0,0xB,0xB,0xB,0x0,0x0,0x0,0xF,
/*C*/ 0x0,0xD,0xE,0x0,0xC,0xD,0xE,0x0,0x0,0xD,0xE,0x0,0xC,0xD,0xE,0xF,
/*D*/ 0x0,0xD,0x0,0x0,0xD,0xD,0x0,0x0,0x0,0xD,0x0,0x0,0xD,0xD,0x0,0xF,
/*E*/ 0x0,0x0,0xE,0x0,0xE,0x0,0xE,0x0,0x0,0x0,0xE,0x0,0xE,0x0,0xE,0xF,
/*F*/ 0x0,0x9,0xA,0xB,0xC,0xD,0xE,0xF,0xF,0xF,0xF,0xF,0xF,0xF,0xF,0xF,
};

int bgbdt_voxlight_blendv(int la, int lb)
{

	int lc;
	if((la>>4)>(lb>>4))
		{ return(la); }

	if((la>>4)==(lb>>4))
	{
		lc=(la&0xF0)|bgbdt_voxlight_blendtab[((la&15)<<4)|(lb&15)];
		return(lc);
	}

	if((la>>4)<((lb>>4)-2))
		return(lb-16);
	lc=((lb-16)&0xF0)|bgbdt_voxlight_blendtab[((la&15)<<4)|(lb&15)];
	return(lc);
}

int BGBDT_VoxLight_UpdateChunkLight(
	BGBDT_VoxWorld *world, BGBDT_VoxChunk *chk)
{
	BGBDT_VoxData td, td1;
	BGBDT_VoxDataStatus tds;
	BGBDT_VoxCoord xyz0;
	BGBDT_VoxTypeInfo *tyi;
	int tix, ds, dst, fl;
	int x, y, z, w;
	int a, b, c;
	int vty_air;
	int i, j, k;
	
	if(!chk)
		return(-1);
	if(!chk->voxinfo)
		return(-1);

	vty_air=BGBDT_VoxelWorld_LookupTypeIndexName(world, "air");

	if(chk->voxinfo && (chk->nvoxinfo==1))
	{
		if((chk->voxinfo[0].vtype&4095)!=vty_air)
			return(0);
		if(chk->voxinfo[0].alight<16)
			{ chk->voxinfo[0].alight=16; }
	}else
	{
		for(i=0; i<chk->nvoxinfo; i++)
		{
			if((chk->voxinfo[i].vtype&4095)!=vty_air)
				break;
		}
		if(i>=chk->nvoxinfo)
		{
			for(j=0; j<chk->nvoxinfo; j++)
			{
				if(chk->voxinfo[j].alight<16)
					{ chk->voxinfo[j].alight=16; }
			}
		}
	}
	
	for(w=0; w<6; w++)
	{
		dst=0;
		for(z=0; z<16; z++)
			for(y=0; y<16; y++)
				for(x=0; x<16; x++)
		{
			BGBDT_WorldGetChunkVoxelData(world,
				x, y, z, chk, &td, &tds,
				BGBDT_ACCFL_NOLOAD|BGBDT_ACCFL_CHKADJ);

			tix=td.vtype&4095;
			tyi=world->voxtypes[tix];
			if(!tyi)continue;

			if(!(tyi->flags&BGBDT_VOXFL_TRANSPARENT))
				continue;
//			if(tix!=vty_air)
//				continue;

			ds=0;
			for(i=0; i<6; i++)
			{
				a=(tds.adjlit[i]>>8)&255;
				if(a>(td.alight+1))
					{ td.alight=a-1; ds=1; }

				b=tds.adjlit[i]&255;
				c=bgbdt_voxlight_blendv(td.vlight, b);
				if(c!=td.vlight)
					{ td.vlight=c; ds=1; }
			}
			
			if(ds)
			{
				dst++;
				xyz0=BGBDT_WorldGetChunkVoxCoord(world, chk, x, y, z);
				BGBDT_WorldSetChunkVoxelData(world, chk, xyz0, td, 
					BGBDT_ACCFL_CHKADJ|BGBDT_ACCFL_LIGHTDIRTY);
			}
		}
		if(!dst)
			break;
	}
	chk->flags&=~BGBDT_CHKFL_LIGHTDIRTY;
	return(0);
}

BTEIFGL_API int BGBDT_VoxLight_ClearBlockLightRadius(
	BGBDT_VoxWorld *world,
	BGBDT_VoxCoord xyz, int accfl)
{
	BGBDT_VoxCoord xyz1;
	BGBDT_VoxData td;
	BGBDT_VoxDataStatus tds;
	int x, y, z;
	int i, j, k;
	
	for(z=-16; z<=16; z++)
		for(y=-16; y<=16; y++)
			for(x=-16; x<=16; x++)
	{
		xyz1.x=xyz.x+(x<<BGBDT_XYZ_SHR_VOXEL);
		xyz1.y=xyz.y+(y<<BGBDT_XYZ_SHR_VOXEL);
		xyz1.z=xyz.z+(z<<BGBDT_XYZ_SHR_VOXEL);
	
		i=BGBDT_WorldGetVoxelData(world, xyz1, &td, &tds, 0);
		if(i<0)
			continue;
		td.vlight=0;
		BGBDT_WorldSetVoxelData(world, xyz1, td, 0);
	}
	return(0);
}

BTEIFGL_API int BGBDT_VoxLight_CheckClearBlockLightRadius(
	BGBDT_VoxWorld *world,
	BGBDT_VoxCoord xyz, int accfl)
{
	BGBDT_VoxData td;
	BGBDT_VoxDataStatus tds;
	int vfl;
	int i;

	i=BGBDT_WorldGetVoxelData(world, xyz, &td, &tds, 0);
	if(i<0)
		return(0);
	vfl=BGBDT_WorldVoxel_GetFlags(world, xyz, td);
	if(vfl&BGBDT_VOXFL_GLOWLIGHT)
	{
		BGBDT_VoxLight_ClearBlockLightRadius(world, xyz, accfl);
	}
	return(0);
}
